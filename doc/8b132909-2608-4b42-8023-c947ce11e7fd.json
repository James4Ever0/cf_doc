{
    "summary": "The code defines a class for X Window Dump format, reads file header and dimensions, converts image to NumPy array, checks contiguity, and handles exceptions.",
    "details": [
        {
            "comment": "The code defines a class \"XWD\" that represents an X Window Dump file format. It initializes the class with input and optional xwd_header, computes intermediate values for universal format, provides info method to retrieve information about the file, and handles exceptions for unsupported features.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd_func.py\":0-48",
            "content": "#!/usr/bin/env python3\nfrom __future__ import division, print_function, unicode_literals\nimport itertools\nimport json\nimport re\nimport struct\nimport numpy as np\n# :python3:buffer: we need to get a binary stream in both\n# Python 2 and Python 3.\ndef binary(stream):\n    if hasattr(stream, \"buffer\"):\n        return stream.buffer\n    else:\n        return stream\nclass FormatError(Exception):\n    pass\nclass NotImplemented(Exception):\n    pass\nclass Channel:\n    def __init__(self, **k):\n        self.__dict__.update(k)\nclass XWD:\n    def __init__(self, input, xwd_header=None):\n        if xwd_header:\n            self.__dict__.update(xwd_header)\n        self.xwd_header = xwd_header\n        self.info_dict = dict(\n            h=self.pixmap_height, w=self.pixmap_width, xwd_header=xwd_header\n        )\n        self.input = input\n    def info(self):\n        return dict(self.info_dict)\n    def uni_format(self):\n        \"\"\"\n        Return the \"universal format\" for the XWD file.\n        As a side effect, compute and cache various\n        intermediate values (such as shifts and depths)."
        },
        {
            "comment": "This code checks the visual_class of a visual and if it is not TrueColor, raises a NotImplemented exception. If the visual_class is TrueColor, it creates three Channel objects for Red, Green, and Blue masks and asserts that all masks are different. It then sorts the channels by Most Significant first.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd_func.py\":49-80",
            "content": "        \"\"\"\n        if \"_uni_format\" in self.__dict__:\n            return self._uni_format\n        # Check visual_class.\n        # The following table from http://www.opensource.apple.com/source/tcl/tcl-87/tk/tk/xlib/X11/X.h is assumed:\n        # StaticGray    0\n        # GrayScale     1\n        # StaticColor   2\n        # PseudoColor   3\n        # TrueColor     4\n        # DirectColor   5\n        if self.visual_class != 4:\n            # TrueColor\n            raise NotImplemented(\n                \"Cannot handle visual_class {!r}\".format(self.visual_class)\n            )\n        # Associate each mask with its channel colour.\n        channels = [\n            Channel(name=\"R\", mask=self.red_mask),\n            Channel(name=\"G\", mask=self.green_mask),\n            Channel(name=\"B\", mask=self.blue_mask),\n        ]\n        # If fails: some masks are the same.\n        assert len(set(c.mask for c in channels)) == 3\n        # Sort Most Significant first\n        channels = sorted(channels, key=lambda x: x.mask, reverse=True)"
        },
        {
            "comment": "This code ensures contiguity of masks, checks if the last mask is on the right (avoiding unused bits), determines shift and bitdepth for each channel, groups channels by their bit depth, and creates a string representation for uni_format while iterating through input data.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd_func.py\":82-112",
            "content": "        # Check that each mask is contiguous.\n        for channel in channels:\n            assert is_contiguous(channel.mask)\n        # Check that each mask abuts the next...\n        for channel, successor in zip(channels, channels[1:]):\n            assert is_contiguous(channel.mask + successor.mask)\n        # ... check that the last mask is on the right.\n        # If fails: least significant bit is unused.\n        # :todo: if it ever occurs in wild, implement a padding\n        # channel, eg: RGB5X1.\n        assert channels[-1].mask & 1\n        # Annotate each channel with its shift and bitdepth.\n        for c in channels:\n            c.shift = ffs(c.mask)\n            c.bits = (c.mask >> c.shift).bit_length()\n        self.channels = channels\n        v = \"\"\n        for (bits, chans) in itertools.groupby(channels, lambda c: c.bits):\n            v += \"\".join(c.name for c in chans)\n            v += str(bits)\n        self._uni_format = v\n        return self.uni_format()\n    def __iter__(self):\n        while True:\n            bs = self.input.read(self.bytes_per_line)"
        },
        {
            "comment": "Function `pixels` takes a row of bytes and converts it into a list of RGB pixels. It first checks if the number of bits per pixel is valid for conversion (must be a multiple of 8 and less than or equal to 4). If not, it raises a NotImplemented error. Then it pads the byte data with zeroes until there are four bytes, and unpacks them using struct.unpack in the appropriate byte order. The result is a list of RGB pixels where each color channel's value is calculated from the pixel byte data according to its mask and shift values.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd_func.py\":113-146",
            "content": "            if len(bs) == 0:\n                break\n            yield list(itertools.chain(*self.pixels(bs)))\n    def __len__(self):\n        return self.pixmap_height\n    def pixels(self, row):\n        self.uni_format()\n        # bytes per pixel\n        bpp = self.bits_per_pixel // 8\n        if bpp * 8 != self.bits_per_pixel or bpp > 4:\n            raise NotImplemented(\n                \"Cannot handle bits_per_pixel of {!r}\".format(self.bits_per_pixel)\n            )\n        for s in range(0, len(row), bpp):\n            pix = row[s : s + bpp]\n            # pad to 4 bytes\n            pad = b\"\\x00\" * (4 - len(pix))\n            if self.byte_order == 1:\n                fmt = \">L\"\n                pix = pad + pix\n            else:\n                fmt = \"<L\"\n                pix = pix + pad\n            v, = struct.unpack(fmt, pix)\n            cs = self.channels\n            # Note: Could permute channels here\n            # by permuting the `cs` list;\n            # for example to convert BGR to RGB.\n            pixel = tuple((v & c.mask) >> c.shift for c in cs)"
        },
        {
            "comment": "This function reads the header of an XWD file and checks for its validity, including the size and version. It expects the header to be in most significant byte first format and raises a FormatError if the size exceeds 65536 or the version is not 7. The function then proceeds with parsing the rest of the file based on this header information.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd_func.py\":148-189",
            "content": "            yield pixel\ndef xwd_open(f):\n    # From XWDFile.h:\n    # \"Values in the file are most significant byte first.\"\n    fmt = \">L\"\n    header = f.read(8)\n    header_size, = struct.unpack(fmt, header[:4])\n    # There are no magic numbers, so as a sanity check,\n    # we check that the size is \"reasonable\" (< 65536)\n    if header_size >= 65536:\n        raise FormatError(\"header_size too big: {!r}\".format(header[:4]))\n    version, = struct.unpack(fmt, header[4:8])\n    if version != 7:\n        raise FormatError(\n            \"Sorry only version 7 supported, not version {!r}\".format(version)\n        )\n    fields = [\n        \"pixmap_format\",\n        \"pixmap_depth\",\n        \"pixmap_width\",\n        \"pixmap_height\",\n        \"xoffset\",\n        \"byte_order\",\n        \"bitmap_unit\",\n        \"bitmap_bit_order\",\n        \"bitmap_pad\",\n        \"bits_per_pixel\",\n        \"bytes_per_line\",\n        \"visual_class\",\n        \"red_mask\",\n        \"green_mask\",\n        \"blue_mask\",\n        \"bits_per_rgb\",\n        \"colormap_entries\",\n        \"ncolors\","
        },
        {
            "comment": "This code is used for parsing an XWD file format, reading the header information such as window dimensions and version. It then reads the window name and ignores the color section of the file. The function `ffs` calculates the least significant set bit index in a number and `is_contiguous` checks if a number is a power of 2.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd_func.py\":190-235",
            "content": "        \"window_width\",\n        \"window_height\",\n        \"window_x\",\n        \"window_y\",\n        \"window_bdrwidth\",\n    ]\n    res = dict(header_size=header_size, version=version)\n    for field in fields:\n        v, = struct.unpack(fmt, f.read(4))\n        res[field] = v\n    xwd_header_size = 8 + 4 * len(fields)\n    window_name_len = header_size - xwd_header_size\n    if window_name_len <= 0:\n        raise FormatError(\"Size in header, {!r}, is too small\".format(size))\n    window_name = f.read(window_name_len)[:-1]\n    res[\"window_name\"] = window_name\n    # read, but ignore, the colours\n    color_fmt = fmt + \">H\" * 3 + \"B\" + \"B\"\n    for i in range(res[\"ncolors\"]):\n        f.read(12)\n    xwd = XWD(input=f, xwd_header=res)\n    return xwd\ndef ffs(x):\n    \"\"\"\n    Returns the index, counting from 0, of the\n    least significant set bit in `x`.\n    \"\"\"\n    return (x & -x).bit_length() - 1\ndef is_contiguous(x):\n    \"\"\"\n    Check that x is a contiguous series of binary bits.\n    \"\"\"\n    return is_power_of_2((x >> ffs(x)) + 1)\ndef is_power_of_2(x):"
        },
        {
            "comment": "The code defines a function `mainConv` which opens an image file and converts it into a NumPy array, rescaling the values to a range of 0-1. It also defines two helper functions: `xwd_open` to read XWD format image files and `dprint` for printing dictionaries in a formatted way. The code chunk also contains an assertion and a bitwise operation that returns True if the input is a power of 2.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd_func.py\":236-257",
            "content": "    assert x > 0\n    return not (x & (x - 1))\ndef dprint(o, indent=0):\n    for k, v in sorted(o.items()):\n        print(\" \" * indent, end=\"\")\n        if isinstance(v, dict):\n            print(k + \":\")\n            dprint(v, indent=indent + 2)\n            continue\n        if \"mask\" in k:\n            v = \"{:#x}\".format(v)\n        print(k, v)\ndef mainConv(inp):\n    xwd = xwd_open(inp)\n    arr = np.array([row for row in xwd])/255.0\n    x,_ = arr.shape\n    arr = arr.reshape(x,-1,3)\n    return arr\n# what is this thing?"
        }
    ]
}