{
    "summary": "The script reads XWD image files, checks for TrueColor visual class, creates RGB masks and reads pixel data. It also includes helper functions to process XWD file information and convert it to PNG format with 8-bit RGB.",
    "details": [
        {
            "comment": "This Python script defines a class `XWD` for processing XWD image files. It takes an input file and optionally an XWD header, and provides methods to extract information about the image's dimensions and format. The class also computes and caches intermediate values needed for further processing.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd.py\":0-50",
            "content": "#!/usr/bin/env python3\nfrom __future__ import division, print_function, unicode_literals\nimport getopt\nimport itertools\nimport json\nimport re\nimport struct\nimport sys\n# :python3:buffer: we need to get a binary stream in both\n# Python 2 and Python 3.\ndef binary(stream):\n    if hasattr(stream, \"buffer\"):\n        return stream.buffer\n    else:\n        return stream\nclass FormatError(Exception):\n    pass\nclass NotImplemented(Exception):\n    pass\nclass Channel:\n    def __init__(self, **k):\n        self.__dict__.update(k)\nclass XWD:\n    def __init__(self, input, xwd_header=None):\n        if xwd_header:\n            self.__dict__.update(xwd_header)\n        self.xwd_header = xwd_header\n        self.info_dict = dict(\n            h=self.pixmap_height, w=self.pixmap_width, xwd_header=xwd_header\n        )\n        self.input = input\n    def info(self):\n        return dict(self.info_dict)\n    def uni_format(self):\n        \"\"\"\n        Return the \"universal format\" for the XWD file.\n        As a side effect, compute and cache various\n        intermediate values (such as shifts and depths)."
        },
        {
            "comment": "This code checks the visual_class and ensures it is TrueColor. It then creates channels for RGB masks, asserting that all masks are unique, sorts them by Most Significant first.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd.py\":51-82",
            "content": "        \"\"\"\n        if \"_uni_format\" in self.__dict__:\n            return self._uni_format\n        # Check visual_class.\n        # The following table from http://www.opensource.apple.com/source/tcl/tcl-87/tk/tk/xlib/X11/X.h is assumed:\n        # StaticGray    0\n        # GrayScale     1\n        # StaticColor   2\n        # PseudoColor   3\n        # TrueColor     4\n        # DirectColor   5\n        if self.visual_class != 4:\n            # TrueColor\n            raise NotImplemented(\n                \"Cannot handle visual_class {!r}\".format(self.visual_class)\n            )\n        # Associate each mask with its channel colour.\n        channels = [\n            Channel(name=\"R\", mask=self.red_mask),\n            Channel(name=\"G\", mask=self.green_mask),\n            Channel(name=\"B\", mask=self.blue_mask),\n        ]\n        # If fails: some masks are the same.\n        assert len(set(c.mask for c in channels)) == 3\n        # Sort Most Significant first\n        channels = sorted(channels, key=lambda x: x.mask, reverse=True)"
        },
        {
            "comment": "Code iterates over channels, checks contiguity of masks, ensures masks abut next, verifies the last mask is on the right, calculates shift and bit depth for each channel, groups channels by bits, stores the grouped format, and returns a function for retrieving the formatted string. It also implements an iterator method.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd.py\":84-114",
            "content": "        # Check that each mask is contiguous.\n        for channel in channels:\n            assert is_contiguous(channel.mask)\n        # Check that each mask abuts the next...\n        for channel, successor in zip(channels, channels[1:]):\n            assert is_contiguous(channel.mask + successor.mask)\n        # ... check that the last mask is on the right.\n        # If fails: least significant bit is unused.\n        # :todo: if it ever occurs in wild, implement a padding\n        # channel, eg: RGB5X1.\n        assert channels[-1].mask & 1\n        # Annotate each channel with its shift and bitdepth.\n        for c in channels:\n            c.shift = ffs(c.mask)\n            c.bits = (c.mask >> c.shift).bit_length()\n        self.channels = channels\n        v = \"\"\n        for (bits, chans) in itertools.groupby(channels, lambda c: c.bits):\n            v += \"\".join(c.name for c in chans)\n            v += str(bits)\n        self._uni_format = v\n        return self.uni_format()\n    def __iter__(self):\n        while True:\n            bs = self.input.read(self.bytes_per_line)"
        },
        {
            "comment": "This code is part of a class that reads pixel data from a binary file and converts it into usable pixel values. It checks the bits_per_pixel value to ensure compatibility, iterates through rows in chunks, unpacks pixel data using struct module, and handles channel permutation if needed. The length of the object is based on pixmap_height attribute. If there are no more bytes in the binary file, it breaks the loop. The code also raises a NotImplemented exception if bits_per_pixel is not divisible by 8 or greater than 4.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd.py\":115-148",
            "content": "            if len(bs) == 0:\n                break\n            yield list(itertools.chain(*self.pixels(bs)))\n    def __len__(self):\n        return self.pixmap_height\n    def pixels(self, row):\n        self.uni_format()\n        # bytes per pixel\n        bpp = self.bits_per_pixel // 8\n        if bpp * 8 != self.bits_per_pixel or bpp > 4:\n            raise NotImplemented(\n                \"Cannot handle bits_per_pixel of {!r}\".format(self.bits_per_pixel)\n            )\n        for s in range(0, len(row), bpp):\n            pix = row[s : s + bpp]\n            # pad to 4 bytes\n            pad = b\"\\x00\" * (4 - len(pix))\n            if self.byte_order == 1:\n                fmt = \">L\"\n                pix = pad + pix\n            else:\n                fmt = \"<L\"\n                pix = pix + pad\n            v, = struct.unpack(fmt, pix)\n            cs = self.channels\n            # Note: Could permute channels here\n            # by permuting the `cs` list;\n            # for example to convert BGR to RGB.\n            pixel = tuple((v & c.mask) >> c.shift for c in cs)"
        },
        {
            "comment": "This function xwd_open reads an XWD file header, checks for a reasonable size (<65536), and ensures the version is 7. It then defines fields for further processing of the image data in the XWD file.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd.py\":150-191",
            "content": "            yield pixel\ndef xwd_open(f):\n    # From XWDFile.h:\n    # \"Values in the file are most significant byte first.\"\n    fmt = \">L\"\n    header = f.read(8)\n    header_size, = struct.unpack(fmt, header[:4])\n    # There are no magic numbers, so as a sanity check,\n    # we check that the size is \"reasonable\" (< 65536)\n    if header_size >= 65536:\n        raise FormatError(\"header_size too big: {!r}\".format(header[:4]))\n    version, = struct.unpack(fmt, header[4:8])\n    if version != 7:\n        raise FormatError(\n            \"Sorry only version 7 supported, not version {!r}\".format(version)\n        )\n    fields = [\n        \"pixmap_format\",\n        \"pixmap_depth\",\n        \"pixmap_width\",\n        \"pixmap_height\",\n        \"xoffset\",\n        \"byte_order\",\n        \"bitmap_unit\",\n        \"bitmap_bit_order\",\n        \"bitmap_pad\",\n        \"bits_per_pixel\",\n        \"bytes_per_line\",\n        \"visual_class\",\n        \"red_mask\",\n        \"green_mask\",\n        \"blue_mask\",\n        \"bits_per_rgb\",\n        \"colormap_entries\",\n        \"ncolors\","
        },
        {
            "comment": "This code reads an X Window Dump (XWD) file and parses its header to create an XWD object. It extracts fields such as window dimensions, position, border width, version, and the window name from the file. The code also includes helper functions like ffs(), is_contiguous(), and is_power_of_2() for bit manipulation and checking if a number is a power of 2 or a contiguous series of binary bits.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd.py\":192-237",
            "content": "        \"window_width\",\n        \"window_height\",\n        \"window_x\",\n        \"window_y\",\n        \"window_bdrwidth\",\n    ]\n    res = dict(header_size=header_size, version=version)\n    for field in fields:\n        v, = struct.unpack(fmt, f.read(4))\n        res[field] = v\n    xwd_header_size = 8 + 4 * len(fields)\n    window_name_len = header_size - xwd_header_size\n    if window_name_len <= 0:\n        raise FormatError(\"Size in header, {!r}, is too small\".format(size))\n    window_name = f.read(window_name_len)[:-1]\n    res[\"window_name\"] = window_name\n    # read, but ignore, the colours\n    color_fmt = fmt + \">H\" * 3 + \"B\" + \"B\"\n    for i in range(res[\"ncolors\"]):\n        f.read(12)\n    xwd = XWD(input=f, xwd_header=res)\n    return xwd\ndef ffs(x):\n    \"\"\"\n    Returns the index, counting from 0, of the\n    least significant set bit in `x`.\n    \"\"\"\n    return (x & -x).bit_length() - 1\ndef is_contiguous(x):\n    \"\"\"\n    Check that x is a contiguous series of binary bits.\n    \"\"\"\n    return is_power_of_2((x >> ffs(x)) + 1)\ndef is_power_of_2(x):"
        },
        {
            "comment": "This code appears to be a function that reads an XWD file and can output information about it or convert it to PNG format. It takes command-line options for \"--info\" or \"--raw\", and if no input filename is provided, it defaults to outputting a file named \"xwd2png_out.png\". The function also ensures that the XWD file's format is set to \"RGB8\".",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd.py\":238-284",
            "content": "    assert x > 0\n    return not (x & (x - 1))\ndef main(argv=None):\n    if argv is None:\n        argv = sys.argv\n    opts, args = getopt.getopt(argv[1:], \"i\", [\"info\", \"raw\"])\n    options = [o for o, v in opts]\n    if len(args) == 0:\n        inp = binary(sys.stdin)\n        out = binary(sys.stdout)\n    else:\n        inp = open(args[0], \"rb\")\n        out = None\n    xwd = xwd_open(inp)\n    if \"-i\" in options or \"--info\" in options:\n        info = xwd.info()\n        dprint(info)\n        return 0\n    if \"--raw\" in options:\n        for row in xwd:\n            print(*row)\n        return 0\n    if out is None:\n        try:\n            inp.name\n        except AttributeError:\n            out = \"xwd2png_out.png\"\n        else:\n            out = re.sub(r\"(\\..*|)$\", \".png\", inp.name)\n            if out == inp.name:\n                # avoid overwriting input,\n                # if, for some reason,\n                # input is mysteriously named: input.png\n                output_name += \".png\"\n    format = xwd.uni_format()\n    assert format == \"RGB8\""
        },
        {
            "comment": "Imports png module, converts xwd to APNG using 8-bit RGB format, saves APNG file with given name. Includes a function dprint() that recursively prints dictionary contents with optional indentation, handles hex values in \"mask\" keys. Main function is executed if script is run directly.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/xwd.py\":286-305",
            "content": "    import png\n    apng = png.from_array(xwd, \"RGB;8\")\n    apng.save(out)\ndef dprint(o, indent=0):\n    for k, v in sorted(o.items()):\n        print(\" \" * indent, end=\"\")\n        if isinstance(v, dict):\n            print(k + \":\")\n            dprint(v, indent=indent + 2)\n            continue\n        if \"mask\" in k:\n            v = \"{:#x}\".format(v)\n        print(k, v)\nif __name__ == \"__main__\":\n    main()"
        }
    ]
}