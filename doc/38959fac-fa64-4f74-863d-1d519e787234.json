{
    "summary": "This Python class parses XWD files, supports error handling and cross-version compatibility, ensures TrueColor visual class, checks RGB masks for uniqueness, and handles pixel data in images. It reads and parses XWD files in 'info' or 'raw' mode, returning an XWD object with window dimensions, name, and utility functions for bit manipulation using binary I/O streams and Python's getopt library.",
    "details": [
        {
            "comment": "This code is a Python class definition for handling XWD files. It includes functions to parse the file's header and convert its data into a universal format. The code also handles potential format errors and uses buffer for compatibility with both Python 2 and 3.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/pypy_xwd.py\":0-50",
            "content": "#!/usr/bin/env pypy3\nfrom __future__ import division, print_function, unicode_literals\nimport getopt\nimport itertools\nimport json\nimport re\nimport struct\nimport sys\nimport pickle\n# :python3:buffer: we need to get a binary stream in both\n# Python 2 and Python 3.\ndef binary(stream):\n    if hasattr(stream, \"buffer\"):\n        return stream.buffer\n    else:\n        return stream\nclass FormatError(Exception):\n    pass\nclass NotImplemented(Exception):\n    pass\nclass Channel:\n    def __init__(self, **k):\n        self.__dict__.update(k)\nclass XWD:\n    def __init__(self, input, xwd_header=None):\n        if xwd_header:\n            self.__dict__.update(xwd_header)\n        self.xwd_header = xwd_header\n        self.info_dict = dict(\n            h=self.pixmap_height, w=self.pixmap_width, xwd_header=xwd_header\n        )\n        self.input = input\n    def info(self):\n        return dict(self.info_dict)\n    def uni_format(self):\n        \"\"\"\n        Return the \"universal format\" for the XWD file.\n        As a side effect, compute and cache various"
        },
        {
            "comment": "This code checks the visual_class and ensures it's TrueColor before creating channels for RGB masks. It asserts that all masks are different and sorts them by Most Significant first.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/pypy_xwd.py\":51-83",
            "content": "        intermediate values (such as shifts and depths).\n        \"\"\"\n        if \"_uni_format\" in self.__dict__:\n            return self._uni_format\n        # Check visual_class.\n        # The following table from http://www.opensource.apple.com/source/tcl/tcl-87/tk/tk/xlib/X11/X.h is assumed:\n        # StaticGray    0\n        # GrayScale     1\n        # StaticColor   2\n        # PseudoColor   3\n        # TrueColor     4\n        # DirectColor   5\n        if self.visual_class != 4:\n            # TrueColor\n            raise NotImplemented(\n                \"Cannot handle visual_class {!r}\".format(self.visual_class)\n            )\n        # Associate each mask with its channel colour.\n        channels = [\n            Channel(name=\"R\", mask=self.red_mask),\n            Channel(name=\"G\", mask=self.green_mask),\n            Channel(name=\"B\", mask=self.blue_mask),\n        ]\n        # If fails: some masks are the same.\n        assert len(set(c.mask for c in channels)) == 3\n        # Sort Most Significant first\n        channels = sorted(channels, key=lambda x: x.mask, reverse=True)"
        },
        {
            "comment": "This code checks the contiguity of masks for each channel, ensures that masks abut next, verifies the least significant bit is not unused, assigns shift and bit depth to channels, generates a unified format string, and creates an iterator for processing data.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/pypy_xwd.py\":85-115",
            "content": "        # Check that each mask is contiguous.\n        for channel in channels:\n            assert is_contiguous(channel.mask)\n        # Check that each mask abuts the next...\n        for channel, successor in zip(channels, channels[1:]):\n            assert is_contiguous(channel.mask + successor.mask)\n        # ... check that the last mask is on the right.\n        # If fails: least significant bit is unused.\n        # :todo: if it ever occurs in wild, implement a padding\n        # channel, eg: RGB5X1.\n        assert channels[-1].mask & 1\n        # Annotate each channel with its shift and bitdepth.\n        for c in channels:\n            c.shift = ffs(c.mask)\n            c.bits = (c.mask >> c.shift).bit_length()\n        self.channels = channels\n        v = \"\"\n        for (bits, chans) in itertools.groupby(channels, lambda c: c.bits):\n            v += \"\".join(c.name for c in chans)\n            v += str(bits)\n        self._uni_format = v\n        return self.uni_format()\n    def __iter__(self):\n        while True:\n            bs = self.input.read(self.bytes_per_line)"
        },
        {
            "comment": "The code handles the pixel data in a pixmap image with a specific number of bits per pixel. It raises an exception if it cannot handle the given bits_per_pixel value, which should be a multiple of 8. The code also ensures that the byte order is consistent and pads the bytes to 4 for proper formatting. If needed, the channels in the pixel can be permuted to change the color format such as converting BGR to RGB.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/pypy_xwd.py\":116-149",
            "content": "            if len(bs) == 0:\n                break\n            yield list(itertools.chain(*self.pixels(bs)))\n    def __len__(self):\n        return self.pixmap_height\n    def pixels(self, row):\n        self.uni_format()\n        # bytes per pixel\n        bpp = self.bits_per_pixel // 8\n        if bpp * 8 != self.bits_per_pixel or bpp > 4:\n            raise NotImplemented(\n                \"Cannot handle bits_per_pixel of {!r}\".format(self.bits_per_pixel)\n            )\n        for s in range(0, len(row), bpp):\n            pix = row[s : s + bpp]\n            # pad to 4 bytes\n            pad = b\"\\x00\" * (4 - len(pix))\n            if self.byte_order == 1:\n                fmt = \">L\"\n                pix = pad + pix\n            else:\n                fmt = \"<L\"\n                pix = pix + pad\n            v, = struct.unpack(fmt, pix)\n            cs = self.channels\n            # Note: Could permute channels here\n            # by permuting the `cs` list;\n            # for example to convert BGR to RGB.\n            pixel = tuple((v & c.mask) >> c.shift for c in cs)"
        },
        {
            "comment": "This function reads the first 8 bytes of an XWD file, checks if the header size is reasonable (less than 65536), and verifies that the version is 7. If any issues are found, it raises a FormatError. The code then prepares to parse other fields in the file based on this initial information.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/pypy_xwd.py\":151-192",
            "content": "            yield pixel\ndef xwd_open(f):\n    # From XWDFile.h:\n    # \"Values in the file are most significant byte first.\"\n    fmt = \">L\"\n    header = f.read(8)\n    header_size, = struct.unpack(fmt, header[:4])\n    # There are no magic numbers, so as a sanity check,\n    # we check that the size is \"reasonable\" (< 65536)\n    if header_size >= 65536:\n        raise FormatError(\"header_size too big: {!r}\".format(header[:4]))\n    version, = struct.unpack(fmt, header[4:8])\n    if version != 7:\n        raise FormatError(\n            \"Sorry only version 7 supported, not version {!r}\".format(version)\n        )\n    fields = [\n        \"pixmap_format\",\n        \"pixmap_depth\",\n        \"pixmap_width\",\n        \"pixmap_height\",\n        \"xoffset\",\n        \"byte_order\",\n        \"bitmap_unit\",\n        \"bitmap_bit_order\",\n        \"bitmap_pad\",\n        \"bits_per_pixel\",\n        \"bytes_per_line\",\n        \"visual_class\",\n        \"red_mask\",\n        \"green_mask\",\n        \"blue_mask\",\n        \"bits_per_rgb\",\n        \"colormap_entries\",\n        \"ncolors\","
        },
        {
            "comment": "This code reads an XWD file, extracts the header information including window dimensions and name, ignores color data, and returns the XWD object. It also includes utility functions for finding the least significant set bit in a number and checking if a series of binary bits is a power of 2.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/pypy_xwd.py\":193-238",
            "content": "        \"window_width\",\n        \"window_height\",\n        \"window_x\",\n        \"window_y\",\n        \"window_bdrwidth\",\n    ]\n    res = dict(header_size=header_size, version=version)\n    for field in fields:\n        v, = struct.unpack(fmt, f.read(4))\n        res[field] = v\n    xwd_header_size = 8 + 4 * len(fields)\n    window_name_len = header_size - xwd_header_size\n    if window_name_len <= 0:\n        raise FormatError(\"Size in header, {!r}, is too small\".format(size))\n    window_name = f.read(window_name_len)[:-1]\n    res[\"window_name\"] = window_name\n    # read, but ignore, the colours\n    color_fmt = fmt + \">H\" * 3 + \"B\" + \"B\"\n    for i in range(res[\"ncolors\"]):\n        f.read(12)\n    xwd = XWD(input=f, xwd_header=res)\n    return xwd\ndef ffs(x):\n    \"\"\"\n    Returns the index, counting from 0, of the\n    least significant set bit in `x`.\n    \"\"\"\n    return (x & -x).bit_length() - 1\ndef is_contiguous(x):\n    \"\"\"\n    Check that x is a contiguous series of binary bits.\n    \"\"\"\n    return is_power_of_2((x >> ffs(x)) + 1)\ndef is_power_of_2(x):"
        },
        {
            "comment": "This code performs XWD file operations and has two modes: 'info' and 'raw'. If the 'info' or '--info' option is specified, it prints information about the XWD file. If the '--raw' option is specified, it dumps all rows of the XWD file without modification in a pickled format. The code uses Python's 'getopt' library to parse command-line options and utilizes binary input/output streams for better compatibility.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/pypy_xwd.py\":239-286",
            "content": "    assert x > 0\n    return not (x & (x - 1))\ndef main(argv=None):\n    if argv is None:\n        argv = sys.argv\n    opts, args = getopt.getopt(argv[1:], \"i\", [\"info\", \"raw\"])\n    options = [o for o, v in opts]\n    if len(args) == 0:\n        inp = binary(sys.stdin)\n        out = binary(sys.stdout)\n    else:\n        inp = open(args[0], \"rb\")\n        out = None\n    xwd = xwd_open(inp)\n    if \"-i\" in options or \"--info\" in options:\n        info = xwd.info()\n        dprint(info)\n        return 0\n    if \"--raw\" in options:\n        pr=[]\n        for row in xwd:\n            pr.append(row)\n#        sys.stdout.__dict__[\"mode\"]=\"wb\"\n        pr=pickle.dump(pr,sys.stdout.buffer)\n#        sys.stdout(pr)\n        return 0\ndef dprint(o, indent=0):\n    for k, v in sorted(o.items()):\n        print(\" \" * indent, end=\"\")\n        if isinstance(v, dict):\n            print(k + \":\")\n            dprint(v, indent=indent + 2)\n            continue\n        if \"mask\" in k:\n            v = \"{:#x}\".format(v)\n        print(k, v)\nif __name__ == \"__main__\":"
        },
        {
            "comment": "main() is a function that serves as the entry point for the program. It acts as the starting point of execution where the main logic of the code resides and performs necessary operations to achieve the desired outcome.",
            "location": "\"/media/root/Prima/works/generated_docs/cf_doc/src/generic/vb_charec_bootstrap/pypy_xwd.py\":287-287",
            "content": "    main()"
        }
    ]
}